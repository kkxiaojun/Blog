# 学习的重点
1. 算法和数据结构是可以训练的
2. 复杂度分析（花大力气学习）

小技巧

1. 边学边练（每周花2个小时，把当周三节内容涉及的数据结构和算法全部自己写出来）
2. 多问、多思考、多搜索
3. 每周跟几个人讨论一下技术问题，每人10分钟左右（发表自己这周所学，所想，或者是有意思的代码）

# 复杂度分析
## 时间复杂度分析
1. 关注循环执行次数最多的一段代码
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
3. 嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

常见的复杂度实例分析
1. 多项式量级（由n作为底数）
2. 非多项式量级（2^n,n!）

常见的多项式时间复杂

* O（1）
* O(logn), O(nlogn),对数阶时间复杂度（归并排序、快速排序的时间复杂度都是O(nlogn)）
  参考等比数列和对数转换

* O（m+n），O（m*n）

## 空间复杂度分析
表示算法的存储空间与数据规模之间的增长关系

# 数组
为什么下标从0开始编号
1. C语言设计从0开始编号
2. 从1开始编号，每次随机访问数组元素都多了一次减法运算

## 线性表
数组、队列、链表、栈

数组和链表的区别（数组支持随机访问，根据下标随机访问的时间复杂度为O（1），连续的内存空间）

## 非线性表
二叉树、堆、图等，数据之间不是简单的前后关系

# 链表
如何实现LUR缓存淘汰算法

思路：
维护一个有序单链表，越靠近链表尾部的节点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表

* 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的节点，并将其从原来的位置删除，然后再插入到链表的头部。
* 如果次数据不在缓存中，分两种情况：
  * 如果缓存未满，插入头部
  * 如果缓存满，删除尾节点，将数据插入头部

1. 单链表
特点：最后的指针不是指向下一个节点，而是指向一个空地址null
2. 循环链表
特点：首尾相连（约瑟夫问题）
3. 双向链表
特点：后继结点、前驱节点

缓存：空间换时间，将数据事先加载在内存中

# 实现浏览器前进后退功能

