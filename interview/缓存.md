# 缓存
## 从性能优化的角度看缓存
### 各类缓存技术优缺点

|缓存技术|优点|缺点|
|---|---|---|
|cookie|对于少量不敏感数据，非常简明有效|容量小（4k）,不安全（cookie劫持，暴露session）,原生接口不友好|
|webStorage|容量较大（5M）, 可做持久化存储|本地存储数据容易被修改|
|indexDB|NoSQL类型的数据库|暂无|
|Manifest|已被web标准废除|暂无|
|web Worker|作为一个独立的线程，是一段在后台运行的脚本|不能访问 DOM,不能使用同步 API,需要HTTPS协议|

### 缓存实践
* 对于不需要缓存的资源用Cache-control: no-store,表示资源不需要缓存
* 对于频繁变动的资源（如经常需要刷新的首页），设置Cache-control:no-cache和Etag，表示资源已被缓存，但是每次都会发送请求询问资源是否更新
* 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。

## 浏览器的缓存机制：强缓存和协商缓存
良好的缓存策略可以减少资源的重复加载提高网页的加载速度

浏览器的缓存策略主要分为两种：强缓存和协商缓存

基本原理

1. 浏览器在加载资源时，根据http请求头的`expires`和`Cache-Control`判断是否命中强缓存。命中，则直接从缓存读取数据。
2. 如果没有命中强缓存，则浏览器一定会发送一个请求到服务器，通过`last-modified`和`etag`验证资源是否命中协商缓存。命中，则服务器会将这个请求返回，**但是不会返回这个资源数据，依然是从缓存中读取数据**
3. 如果两个都没有命中，则直接从服务器加载资源

相同点

都是从客户端缓存读取数据

不同点

强缓存不用发送请求，协商缓存要发送请求

### 强缓存
https://github.com/amandakelake/blog/issues/41
**Expires**
* `expires`是http/1.0提出的表示过期时间的header, 它描述的是一个绝对时间，由服务器返回。
* `expires`受限于本地时间，若是本地时间修改，可能会造成缓存失效。

**Cache-control**
* `Cache-control: max-age=315360000`是http/1.1的内容，优先级高于expires,表示的是相对时间

### 协商缓存
如果浏览器没有命中强缓存，则会发送一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回Http状态码为304，并且会显示一个Not-modified

协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的

1. Last-Modified、If-Modified-Since

Last-Modified表示本地文件最后修改时间，浏览器会在request header加上If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。

但是，如果在本地打开缓存文件，也会造成Last-Modified改变，所以http/1.1引入了Etag

2. ETag、If-None-Match

Etag就像是指纹，资源变化都会导致Etag变化，与时间无关，If-None-Match的header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来

ETag的优先级比Last-Modified更高

为什么用Etag:

* 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；
* 某些服务器不能精确的得到文件的最后修改时间



