# 服务端渲染
## 服务端渲染的运行机制
1. renderToString(), 把Vue实例转化为真实DOM的关键方法
2. 将转化结果塞入模板


服务端渲染解决的性能问题：首屏加载速度慢

将多个浏览器的渲染压力集中到服务器，服务器压力山大

**JS的三种加载方式**

*   正常模式：
    
    ```
    <script src="index.js"></script>
    
    ```
    

这种情况下 JS 会阻塞浏览器，浏览器必须等待 index.js 加载和执行完毕才能去做其它事情。

*   async 模式：
    
    ```
    <script async src="index.js"></script>
    
    ```
    

async 模式下，JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会**立即执行**。

*   defer 模式：
    
    ```
    <script defer src="index.js"></script>
    
    ```
    

defer 模式下，JS 的加载是异步的，执行是**被推迟的**。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始依次执行。

从应用的角度来说，一般当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。

通过审时度势地向 script 标签添加 async/defer，我们就可以告诉浏览器在等待脚本可用期间不阻止其它的工作，这样可以显著提升性能。

## dom渲染的优化原理
**dom为什么这么慢**
JS引擎和渲染引擎（浏览器内核）是独立实现的，JS操作DOM的时候，需要建立两个引擎之间的**跨界交流**，**跨界交流*要收费——这个开销本身就是不可忽略的。所以减少DOM操作是有原因的

**修改了dom引发的迭代**
JS引擎连接上了渲染引擎后的更改操作带来的结果也很慢。

当我们对 DOM 的修改会引发它外观（样式）上的改变时，就会触发**回流**或**重绘**。

1. 回流(reflow). DOM修改引发DOM 几何尺寸的变化
2. 重绘(repaint). DOM修改导致了样式的变化、却并未影响其几何属性

小结论：回流一定会发生重绘，重绘不一定会导致回流。

**如何减少DOM操作**
1. JS 层面的事情，JS 自己去处理，处理好了，再来找 DOM 打报告。
```
<div id="container"></div>

// JS 层面的事情，JS 自己去处理，处理好了，再来找 DOM 打报告。
let container = document.getElementById('container')
let content = ''
for(let count=0;count<10000;count++){ 
  // 先对内容进行操作
  content += '<span>我是一个小测试</span>'
} 
// 内容处理好了,最后再触发DOM的更改
container.innerHTML = content

```

2. 运用DocumentFragment，DOM Fragment 作为经典的性能优化手段大受欢迎，这一点在 jQuery、Vue 等优秀前端框架的源码中均有体现。
> DocumentFragment 接口表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。因为 DocumentFragment 不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。

```
let container = document.getElementById('container')
// 创建一个DOM Fragment对象作为容器
let content = document.createDocumentFragment()
for(let count=0;count<10000;count++){
  // span此时可以通过DOM API去创建
  let oSpan = document.createElement("span")
  oSpan.innerHTML = '我是一个小测试'
  // 像操作真实DOM一样操作DOM Fragment对象
  content.appendChild(oSpan)
}
// 内容处理好了,最后再触发真实DOM的更改
container.appendChild(content)
```

## Event Loop
**Micro-Task 与 Macro-Task**

事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。

常见的 macro-task 比如： setTimeout、setInterval、 setImmediate、 I/O 操作、UI 渲染等。  （优先级 setImmediate>setTimeout）
常见的 micro-task 比如: process.nextTick、Promise、MutationObserver 等。(优先级 process.nextTick>Promise)

**Event Loop的过程**
完整的Event Loop的过程可以解析为一下方面：
1. 初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。
2. 在task执行过程中，同步任务执行完毕
3. API注册函数直接进入自身对应的task/microtask队列
4. Event Loop继续检查microtask队列是否为空，依次执行直至清空队列

**Vue的nextTick**
Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。

## 

