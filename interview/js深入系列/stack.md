# 调用堆栈
## 1.1 理解JavaScript中的执行上下文和执行栈
**执行上下文的类型**
执行上下文共三种类型：
1. 全局执行上下文。只有一个，浏览器中的全局对象是window,this指向之歌全局对象。
2. 函数执行上下文。存在多个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文。
3. eval执行上下文。指的是运行在eval函数中的代码。

**执行栈**
执行栈也叫调用栈。栈是FILO规则的。

1. 首次运行js代码时，会创建一个全局执行上下文并push到当前的执行栈中。
2. 发生函数调用时，会创建一个新的函数执行上下文并push到当前的执行栈中。
3. 当栈顶函数执行完成后，其对应的函数执行上下文将会从执行栈中pop出

**执行上下文的创建**
执行上下文分为两个阶段：
1. 创建阶段
2. 执行阶段

**创建阶段**
* 确定this，this Binding。
* LexicalEnvironment(词法环境)组件被创建。
* VariableEnvironment(变量环境)组件被创建。

**This Binding**
* 全局执行上下文中,`this`值指向全局对象，在浏览器中，`this`指向window对象。在`nodejs`中，指向这个文件的`module`中
* 函数执行上下文中，`this`值指向由调用方式决定，有：默认绑定、隐式绑定、显示绑定、new绑定、箭头函数

## 1.2 JavaScript深入之内存空间和内存机制
**变量的存放**
1. 基本类型。

保存在栈内存中，因为这些类型在内存中分别占有固定大小的空间，通过按值来访问。基本类型一共有6种：Undefined、Null、Boolean、Number 、String和Symbol

2. 引用类型 。

保存在堆内存中，因为这种值的大小不固定，因此不能把它们保存到栈内存中，但内存地址大小的固定的，因此保存在堆内存中，在栈内存中存放的只是该对象的访问地址。当查询引用类型的变量时， 先从栈中读取内存地址， 然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问。

**注意**
就是**闭包中的变量并不保存中栈内存中**，而是保存在堆内存中，这也就解释了函数之后之后为什么闭包还能引用到函数内的变量。

## 1.3 Javascript深入常见内存泄漏及如何避免
### 常见的JS内存泄漏
1. 意外的全局变量
```
function demo() {
  demo = 'demo'
}
function demo() {
  this.demo = 'demo'
}
```
未定义的变量会创建一个新的全局变量, `this`也可能创建意外的全局变量

解决方案：在 JavaScript 文件头部加上 'use strict'，使用严格模式避免意外的全局变量，此时上例中的this指向undefined。如果必须使用全局变量存储大量数据时，确保用完以后把它设置为 null 或者重新定义。

2. 计时器和回调函数
用`setInterval`时记得及时清除定时器

3. 闭包