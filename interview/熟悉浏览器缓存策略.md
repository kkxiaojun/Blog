# 熟悉浏览器缓存策略
对于缓存，chrome给出的解释：
> 通过网络获取内容既速度缓慢又开销巨大。较大的响应需要在客户端与服务器之间进行多次往返通信，这会延迟浏览器获得和处理内容的时间，还会增加访问者的流量费用。因此，缓存并重复利用之前获取的资源的能力成为性能优化的一个关键方面。

浏览器缓存按照资源的获取顺序有以下四个方面：

1. Memory Cache
2. Service Worker Cache
3. HTTP Cache
4. Push Cache

**Service Worker Cache**
```

```

## 从性能优化的角度看缓存
### 各类缓存技术优缺点

|缓存技术|优点|缺点|
|---|---|---|
|cookie|对于少量不敏感数据，非常简明有效|容量小（4k）,不安全（cookie劫持，暴露session）,原生接口不友好|
|webStorage|容量较大（5M）, 可做持久化存储|本地存储数据容易被修改|
|indexDB|NoSQL类型的数据库|暂无|
|Manifest|已被web标准废除|暂无|
|web Worker|作为一个独立的线程，是一段在后台运行的脚本|不能访问 DOM,不能使用同步 API,需要HTTPS协议|

## 浏览器的缓存机制：强缓存和协商缓存
良好的缓存策略可以减少资源的重复加载提高网页的加载速度

浏览器的缓存策略主要分为两种：强缓存和协商缓存

基本原理

1. 浏览器在加载资源时，根据http请求头的`expires`和`Cache-Control`判断是否命中强缓存。命中，则直接从缓存读取数据。
2. 如果没有命中强缓存，则浏览器一定会发送一个请求到服务器，通过`last-modified`和`etag`验证资源是否命中协商缓存。命中(http 状态码为 304)，则服务器会将这个请求返回，**但是不会返回这个资源数据，依然是从缓存中读取数据**
3. 如果两个都没有命中，则直接从服务器加载资源

相同点

都是从客户端缓存读取数据

不同点

强缓存不用发送请求，协商缓存要发送请求

### 强缓存
强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。

**Expires**
* `expires`是http/1.0提出的表示过期时间的header, 它描述的是一个绝对时间（时间格式：new Date()），由服务器返回。
* `expires`受限于本地时间，若是本地时间修改，可能会造成缓存失效。考虑到 expires 的局限性，HTTP1.1 新增了 Cache-Control 字段来完成 expires 的任务

**Cache-control**
* `Cache-control: max-age=3153600`是http/1.1的内容，优先级高于expires,表示的是时间长度3153600秒。Cache-Control 相对于 expires 更加准确，它的优先级也更高。

**s-maxage**
* `s-maxage`优先级高于max-age

**no-store与no-cache**
* no-cache 绕开了浏览器：我们为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期（即走我们下文即将讲解的协商缓存的路线）。

* no-store 比较绝情，顾名思义就是不使用任何缓存策略。在 no-cache 的基础上，它连服务端的缓存确认也绕开了，只允许你直接向服务端发送请求、并下载完整的响应。

**public、private**
如果我们为资源设置了 public，那么它既可以被浏览器缓存，也可以被代理服务器缓存；如果我们设置了 private，则该资源只能被浏览器缓存。

### 协商缓存（浏览器与服务器合作之下的缓存策略）
如果浏览器没有命中强缓存，则会发送一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回Http状态码为304，并且会显示一个Not-modified

协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的

1. Last-Modified、If-Modified-Since

Last-Modified表示本地文件最后修改时间，浏览器会在request header加上If-Modified-Since（上次返回的Last-Modified的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。

但是，如果在本地打开缓存文件，也会造成Last-Modified改变，所以http/1.1引入了Etag

2. ETag、If-None-Match

Etag就像是指纹，资源变化都会导致Etag变化，与时间无关，If-None-Match的header会将上次返回的Etag发送给服务器，询问该资源的Etag是否有更新，有变动就会发送新的资源回来

**Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能**

ETag的优先级比Last-Modified更高

为什么用Etag:

* 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；
* 某些服务器不能精确的得到文件的最后修改时间

### 缓存实践
* 对于不需要缓存的资源用Cache-control: no-store,表示资源不需要缓存
* 对于频繁变动的资源（如经常需要刷新的首页），设置Cache-control:no-cache和Etag，表示资源已被缓存，但是每次都会发送请求询问资源是否更新
* 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。

# 参考文章
* [https://zhuanlan.zhihu.com/p/28113197](https://zhuanlan.zhihu.com/p/28113197)

# 一个参加面试很实用的套路：

就是仔细研究几个比较常问的问题（增加自己的回答深度，以展示自己的实力），
基本套路：
1. 说基本知识点
2. 谈自己在项目上的应用
3. 做个总结


举例：

一般没有套路的回答（只回答知道的知识点）：
问：说说浏览器缓存机制
答：
1. 浏览器的缓存策略有强缓存和协商缓存
2. 强缓存和协商缓存都是直接从缓存里面读取数据
3. 吧啦吧啦（就是把自己知道的说完就算了）

套路满满的回答（主要是分层次回答）：

基本思路：
1. 回答基本知识点（但是要把握重点）。一定说出：缓存机制涉及到的细的知识点（304，Expires，Cache-control，Last-Modified、If-Modified-Since），记不住就多看几遍，理解最重要
2. 接着，谈自己在项目上的应用。（没有就编一个简单的）
3. 最后，来个浏览器缓存机制的总结。
